from motor.motor_asyncio import AsyncIOMotorClient
from pymongo import ASCENDING, DESCENDING, TEXT
from app.config import settings
import logging
import asyncio

logger = logging.getLogger(__name__)

class MongoDB:
    client: AsyncIOMotorClient = None
    db = None
    _connected: bool = False

mongodb = MongoDB()

async def connect_to_mongo(max_retries: int = 3, retry_delay: int = 2) -> bool:
    """Connect to MongoDB on startup with retry logic

    Returns:
        bool: True if connection successful, False otherwise
    """
    for attempt in range(1, max_retries + 1):
        try:
            logger.info(f"Attempting MongoDB connection (attempt {attempt}/{max_retries})...")

            # Create client with timeout
            mongodb.client = AsyncIOMotorClient(
                settings.MONGODB_URL,
                serverSelectionTimeoutMS=5000,  # 5 second timeout
                connectTimeoutMS=5000
            )
            mongodb.db = mongodb.client[settings.DATABASE_NAME]

            # Test connection with ping - THIS IS CRITICAL
            await mongodb.client.admin.command('ping')
            logger.info("MongoDB ping successful")

            # ----------------------------------------------------------------
            # Core collection indexes (original)
            # ----------------------------------------------------------------
            await mongodb.db.found_items.create_index([("item_id", ASCENDING)], unique=True)
            await mongodb.db.found_items.create_index([("category", ASCENDING)])
            await mongodb.db.found_items.create_index([("created_at", DESCENDING)])

            # Full-text index on found_items for BM25-style keyword search
            # Covers description + searchable_tokens (added by batch extractor)
            try:
                await mongodb.db.found_items.create_index(
                    [("description", TEXT), ("searchable_tokens", TEXT)],
                    name="found_items_text_search"
                )
            except Exception:
                pass  # index may already exist

            # ----------------------------------------------------------------
            # Gemini result cache collection
            # ----------------------------------------------------------------
            await mongodb.db.gemini_cache.create_index(
                [("cache_key", ASCENDING)], unique=True
            )
            # TTL index: documents auto-expire after gemini_cache_ttl_seconds
            await mongodb.db.gemini_cache.create_index(
                [("expires_at", ASCENDING)],
                expireAfterSeconds=0  # expire AT the expires_at date
            )

            # ----------------------------------------------------------------
            # Lost query log
            # ----------------------------------------------------------------
            await mongodb.db.lost_item_queries.create_index([("query_id", ASCENDING)], unique=True)
            await mongodb.db.lost_item_queries.create_index([("cache_key", ASCENDING)])
            await mongodb.db.lost_item_queries.create_index([("created_at", DESCENDING)])

            # ----------------------------------------------------------------
            # Match Impressions â€” critical for negative sampling
            # ----------------------------------------------------------------
            await mongodb.db.match_impressions.create_index(
                [("impression_id", ASCENDING)], unique=True
            )
            await mongodb.db.match_impressions.create_index([("query_id", ASCENDING)])
            await mongodb.db.match_impressions.create_index([("timestamp", DESCENDING)])

            # ----------------------------------------------------------------
            # Match Selections
            # ----------------------------------------------------------------
            await mongodb.db.match_selections.create_index([("impression_id", ASCENDING)])
            await mongodb.db.match_selections.create_index([("selected_found_id", ASCENDING)])
            await mongodb.db.match_selections.create_index([("query_id", ASCENDING)])

            # ----------------------------------------------------------------
            # Handover Verifications (may already exist)
            # ----------------------------------------------------------------
            await mongodb.db.handover_verifications.create_index([("lost_id", ASCENDING)])
            await mongodb.db.handover_verifications.create_index([("found_id", ASCENDING)])
            await mongodb.db.handover_verifications.create_index([("verified_at", DESCENDING)])

            logger.info("All database indexes created/verified")

            mongodb._connected = True
            logger.info(f"Connected to MongoDB: {settings.DATABASE_NAME}")
            return True

        except Exception as e:
            logger.error(f"MongoDB connection attempt {attempt} failed: {e}")

            if attempt < max_retries:
                logger.info(f"Retrying in {retry_delay} seconds...")
                await asyncio.sleep(retry_delay)
            else:
                logger.error("All MongoDB connection attempts failed")
                logger.info("System will run in standalone mode with disk cache")
                mongodb._connected = False
                return False

    return False

def is_mongodb_connected() -> bool:
    """Check if MongoDB is connected and ready"""
    return mongodb._connected and mongodb.client is not None and mongodb.db is not None

async def close_mongo_connection():
    """Close MongoDB connection on shutdown"""
    if mongodb.client:
        mongodb.client.close()
        logger.info("MongoDB connection closed")

def get_database():
    """Get database instance

    Returns:
        Database instance if connected, None otherwise
    """
    if is_mongodb_connected():
        return mongodb.db
    return None
